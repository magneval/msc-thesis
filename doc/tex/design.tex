\chapter{Design}

\section{Document management}

\subsection{The SharePoint library}

The Java implementation is split to two parts, the generic SharePoint library
and the user interface, which is an UNO component. The previous lives under the
\emph{hu.ulx.lpsp.sharepoint} namespace, the other does so under
\emph{hu.ulx.lpsp.comp}.

The UML package diagram on figure~\ref{fig:design-packages} diagram shows these
packages with their dependencies.

\begin{figure}[H]
\centering
\includegraphics[width=425px,keepaspectratio]{design-packages.pdf}
\caption{Packages of the document management extension}
\label{fig:design-packages}
\end{figure}

At the time of writing, there is no ready to use Java library to communicate
with a SharePoint server. Because of this, we decided to separate the SharePoint
protocol implementation from the LibreOffice-specific part of the extension to
make it reusable in other projects. It provides the following classes:

\begin{itemize}
\item \emph{SPHandler}: Handles requests from a frontend. Unless a feature has a
specific class, it is implemented here.
\item \emph{FileOpenParser}: Parses the result from the \emph{list directory of
a workspace} request.
\item \emph{FileOpenRootParser}: Parses the result from the \emph{list
workspaces} request.
\item \emph{HandlerTest}: Automatically tests all features on a given server
using JUnit.
\item \emph{LastModParser}: Parses the result from the \emph{get last
modification date} request.
\item \emph{Messages}: Provides localization for the library error messages.
\item \emph{PacketParser}: Extracts the error message from a Vermeer
RPC\cite{vermeer} response packet.
\item \emph{Version}: Handles document versions.
\end{itemize}

We paid attention in our solution to not require additional server-side component
installation, the SharePoint library can communicate with a standard SharePoint
server, without any server modifications.

\subsection{The UNO interfaces}

\begin{figure}[H]
\centering
\includegraphics[width=400px,keepaspectratio]{design-technologies.pdf}
\caption{Technologies used in the design of the extension}
\label{fig:design-technologies}
\end{figure}

The UNO interfaces are modelled after the already referenced OPAL extension.
Where it made sense, we reused code from there, and changed it to work with
Sharepoint.

It's an UNO convention that interfaces start with a capital X. The following
interfaces are provided by the extension (see figure~\ref{fig:design-technologies}):

\begin{itemize}
\item \emph{XSharepointFilePicker}: an open/save as file picker.
\item \emph{XSharepointVersions}: a versions dialog.
\item \emph{XAuthenticationManager}: a handler for different authentication mechanisms.
\item \emph{XConnection}: a connection to a SharePoint server.
\item \emph{XSharepointDocument}: a document received from the
SharePoint server.
\item \emph{XSharepointDocumentManager}: a storage for XSharepointDocument instances.
\end{itemize}

The extension provides a single exception type -- \emph{SharepointException} --
when it throws errors.

It also provides a single enumeration type -- \emph{FileTypes} -- to declare
the list of LibreOffice applications it handles. (It's current value is:
Writer, Calc, Impress and Draw.)

UNO services are interfaces containing static methods only.  The following
services are provided by the extension (see figure~\ref{fig:design-technologies}):

\begin{itemize}
\item \emph{Connection}: implementation for XConnection.
\item \emph{SharepointDocument}: factory for XSharepointDocument.
\item \emph{theAuthenticationManager}: singleton for XAuthenticationManager.
\item \emph{theSharepointDocumentManager}: singleton for XSharepointDocumentManager.
\item \emph{SharepointFilePicker}: implementation for XSharepointFilePicker.
\item \emph{SharepointVersions}: implementation for XSharepointVersions.
\end{itemize}

\subsection{User interface}

The user interface lives in the \emph{hu.ulx.lpsp.comp} package. The classes of
the user interface are organized in 4 Java packages:

\begin{itemize}
\item \emph{hu.ulx.lpsp.comp.model}: a model for the folder and document
structure, used by the file pickers (\emph{open} and \emph{save as} dialog
windows).
\item \emph{hu.ulx.lpsp.comp.ui}: contains the dialog classes.
\item \emph{hu.ulx.lpsp.comp.util}: miscellaneous utility classes for UNO and localization.
\item \emph{hu.ulx.lpsp.comp}: classes implementing the rest of UNO
services: authentication manager, document manager, document, connection, etc.
\end{itemize}

The user interface dialogs are reachable from the \emph{Document repository}
menu item, which is registered by the \emph{Addons.xcu} configuration file,
which is a standard configuration file of LibreOffice extensions.

The following menu items are designed (see figure~\ref{fig:design-technologies}):

\begin{itemize}
\item Connection: force connecting to an other document management server, even
if the user is already connected.
\item Open: downloads an existing document from the server.
\item Close: discards the local copy of a downloaded document.
\item Save: save the document model and upload the saved local copy to the server.
\item Save as: upload the local document to the server using a new name.
\item Versions: management of document versions.
\end{itemize}

The menu items call BASIC macros, which invoke UNO services. Those services are
finally implemented in the Java user interface.

The macros are split into two packages: the ones directly called by the menu
items, and the other utility macros.

The menu items call the following macros (\emph{LPSP.menu} package) (see figure~\ref{fig:design-technologies}):

\begin{itemize}
\item openFile: shows the File Open dialog.
\item openVersion: shows the dialog listing versions of the document.
\item saveFile: saves the document via the document manager.
\item saveAsFile: shows the Save As dialog.
\item closeFile: closes the current document via the document manager, the
already registered close listener will handle the cleanup of the local document
copy.
\end{itemize}

The following ones are the utility macros (\emph{LPSP.utils} package):

\begin{itemize}
\item getCurrentSharepointDocument: asks the document model of the current LibreOffice component (Writer document, Calc spreadsheet, etc.) from the document manager.
\item getCurrentConnection: asks the current connection from the authentication manager.
\item getConnection: shows the Connection dialog.
\item getDocumentManager: returns the document manager singleton.
\item getAuthenticationManager: returns the document manager singleton.
\end{itemize}

The BASIC macros invoke the following UNO Services:

\begin{itemize}
\item Connection: calls \emph{theAuthenticationManager::execute()}.
\item Open: calls \emph{SharepointFilePicker::execute()} with \emph{IsOpen = true}.
\item Close: calls \emph{theSharepointDocumentManager::getSharepointDocument()}, \\ then the \emph{close} method on the returned result.
\item Save: calls \emph{theSharepointDocumentManager::getSharepointDocument()}, \\ then the \emph{save} method on the returned result.
\item Save as: calls \emph{SharepointFilePicker::execute()} with \emph{IsOpen = false}.
\item Versions: calls \emph{SharepointVersions::execute()}
\end{itemize}

At this point, we know the user interface entry points in our Java
implementation. As mentioned above, Java bytecode for the UNO services are
automatically generated (by \emph{javamaker}). Now one may ask: how does the
stub know where is the real implementation? This is handled by the
\emph{RegistrationHandler} class. The list of implementation classes
implementing a UNO service is in the \emph{RegistrationHandler.classes} file.
Each implementation class specifies what service does it implement, then the
registration handler collects this information and sends it to UNO, when it is
asked. Finally, the \emph{RegistrationClassName:} header in the
\emph{META-INF/MANIFEST.MF} file of the Jar package defines the registration
handler class name.

As a result, the following entry points are designed in the Java
implementation (see figure~\ref{fig:design-technologies}):

\begin{itemize}
\item Connection: \emph{AuthenticationManagerImpl.execute()}
\item Open: \emph{SharepointFilePickerImpl.execute()}
\item Close: \emph{SharepointDocumentManagerImpl.getSharepointDocument()}, \\ then \emph{SharepointDocumentImpl.close()}
\item Save: \emph{SharepointDocumentManagerImpl.getSharepointDocument()}, \\ then \emph{SharepointDocumentImpl.save()}
\item Save as: \emph{SharepointFilePickerImpl.execute()}
\item Versions: \emph{SharepointVersionsImpl.execute()}
\end{itemize}

These classes contain all the business logic and they call the SharePoint
library for communication. The dialog windows are separated from UNO
interfaces, they are always implemented in separate classes. Given that there
are common tasks for all of our user interface dialogs, there is a common
ancestor for all of them, called \emph{AbstractDialog}.

The following dialog classes are included in the \emph{ui} package (see figure~\ref{fig:design-technologies}):

\begin{itemize}
\item Connection: \emph{ConnectionDialog} (connect dialog), \\
\emph{ConfigServerDialog} (server list), \\ \emph{ServerDialog} (settings for an
individual target)
\item Open, save as: \emph{FilePickerDialog}
\item Close: None.
\item Save: \emph{CommentVersionDialog}
\item Versions: \emph{VersionsDialog}
\end{itemize}

For an UML class diagram showing these classes, see figure~\ref{fig:design-spui}.

\begin{figure}[p]
\centering
\includegraphics[width=400px,keepaspectratio]{design-spui.pdf}
\caption{Classes of the user interface}
\label{fig:design-spui}
\end{figure}

\section{Workflows}

\subsection{The workflow library}

Similar to the document management support part, the Java implementation of
workflow support is split to two parts as well: a generic jBPM client library
and the workflow user interface. The jBPM client is designed under the
\emph{hu.ulx.lpsp.workflow} namespace, the second is under the
\emph{hu.ulx.lpsp.comp} one.

\begin{figure}[H]
\centering
\includegraphics[width=425px,keepaspectratio]{design-packages-wf.pdf}
\caption{Packages of the workflow-enabled SharePoint extension}
\label{fig:design-packages-wf}
\end{figure}

Figure~\ref{fig:design-packages-wf} shows the updated UML package diagram of our
solution. The recently introduced \emph{hu.ulx.lpsp.workflow} package can be divided to three
parts:

\begin{itemize}
\item controller classes
\item entity classes
\item parser classes
\end{itemize}

\subsubsection*{Controller classes}

Given that jBPM provides a REST API to control the workflow engine, the client
library can be quite simple. Its business logic is implemented in a single
class, called \emph{WFHandler}. It should provide the following features:

\begin{itemize}
\item authentication handling
\item wrappers for used REST method calls
\item mapping between JSON data and entity classes
\item parsing task data from HTML forms
\end{itemize}

Note that jBPM itself is stateless, but the client library mimics a stateful
connection to avoid asking for connection parameters before all operations.

A decision we made here is that we don't support all kind of process
definitions, only the document-based ones. Our definition of being
document-based is:

\begin{itemize}
\item the process definition has a string variable named \emph{url}
\item the process definition has a task form, where this URL can be specified on process start
\end{itemize}

\subsubsection*{Parser classes}

Whenever a REST method call returns from jBPM, the result can one of the following formats:

\begin{itemize}
\item HTML, when getting a task form
\item XML, when asked for process instance data
\item JSON, in any other case
\end{itemize}

There are multiple problems with arbitrary HTML in our case:

\begin{itemize}
\item jBPM expects an embedded HTML engine in the client, which is not the case with out SWING-based Java user interface
\item once the form is submitted, the server would instruct the user to close
the window, which would be inconsistent with our consistent ``the window is
closed when no more input should be provided'' approach
\item in our case the form should be extended to ask for document-management details as well
\end{itemize}

When using HTML, there are several ways to express business decision. Some example:

\begin{itemize}
\item using separate buttons for each decision
\item using the HTML \texttt{<select>} tag to list choices
\item using radio buttons
\item some AJAX method
\end{itemize}

It is obviously impossible to support all these methods, so we declared a
second constraint here: decisions should be described using submit buttons.

As a result, the \emph{FormParser} class can simply parse submit tag name-value
pairs from the form to detect multiple choices, and the list of values is sent
to the user interface.

\subsubsection*{Entity classes}

Whenever a JSON data structure is returned by a REST method call, the client
library provides the results as an entity class. A convention we follow here is that every type has two entity classes:

\begin{itemize}
\item \emph{TypeRef}: a reference to the instance of the given type itself
\item \emph{TypeRefWrapper}: a class for the collection of instance references of the given type
\end{itemize}

This is handy because this way we don't have to decide what Java interface
(\emph{java.util.List} could be a candidate) can cover all the details the
server provides about an instance list.

The following types are handled by the client:

\begin{itemize}
\item \emph{Process}: is a process definition
\item \emph{ProcessInstance}: is a process instance
\item \emph{NodeInstance}: is a node instance
\item \emph{Task}: a task instance
\end{itemize}

The type names are in sync with the REST API, which is more helpful than simply
trying to be consistent with ourselves -- and store the result of a task query
in a task instance type.

\subsection{BPM server and BPM console}

\begin{figure}[p]
\centering
\includegraphics[width=300px,keepaspectratio]{jbpm-modified-classes.pdf}
\caption{Audit log provider classes of jBPM}
\label{fig:jbpm-modified-classes}
\end{figure}

\subsection{User interface}

\begin{figure}[p]
\centering
\includegraphics[width=400px,keepaspectratio]{design-wfui.pdf}
\caption{Classes of the workflow user interface}
\label{fig:design-wfui}
\end{figure}
